name: Deploy to BunnyCDN

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Deploy to BunnyCDN Storage
      env:
        BUNNY_STORAGE_ZONE: ${{ secrets.BUNNY_STORAGE_ZONE }}
        BUNNY_STORAGE_PASSWORD: ${{ secrets.BUNNY_STORAGE_PASSWORD }}
        BUNNY_STORAGE_ENDPOINT: ${{ secrets.BUNNY_STORAGE_ENDPOINT }}
      run: |
        # Debug: Check if variables are set
        echo "BUNNY_STORAGE_ZONE: ${BUNNY_STORAGE_ZONE:+SET}"
        echo "BUNNY_STORAGE_PASSWORD: ${BUNNY_STORAGE_PASSWORD:+SET}"
        echo "BUNNY_STORAGE_ENDPOINT: ${BUNNY_STORAGE_ENDPOINT:+SET}"
        
        # Exit if any required variable is missing
        if [ -z "$BUNNY_STORAGE_ZONE" ] || [ -z "$BUNNY_STORAGE_PASSWORD" ] || [ -z "$BUNNY_STORAGE_ENDPOINT" ]; then
          echo "ERROR: One or more required secrets are not set!"
          echo "Please configure the following secrets in your GitHub repository:"
          echo "- BUNNY_STORAGE_ZONE"
          echo "- BUNNY_STORAGE_PASSWORD"
          echo "- BUNNY_STORAGE_ENDPOINT"
          exit 1
        fi
        
        # Install curl if not available
        which curl || sudo apt-get update && sudo apt-get install -y curl
        
        # Function to upload files recursively
        upload_directory() {
          local local_path=$1
          local remote_path=$2
          
          # Upload files in current directory
          for file in "$local_path"/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              # URL encode the filename to handle spaces
              encoded_filename=$(echo -n "$filename" | sed 's/ /%20/g')
              encoded_path=$(echo -n "${remote_path}${encoded_filename}" | sed 's/ /%20/g')
              
              echo "Uploading: $file to ${remote_path}${filename}"
              curl -X PUT \
                -H "AccessKey: $BUNNY_STORAGE_PASSWORD" \
                -H "Content-Type: $(file -b --mime-type "$file")" \
                --data-binary "@$file" \
                --fail-with-body \
                "https://${BUNNY_STORAGE_ENDPOINT}.bunnycdn.com/${BUNNY_STORAGE_ZONE}${encoded_path}"
            elif [ -d "$file" ]; then
              dirname=$(basename "$file")
              upload_directory "$file" "${remote_path}${dirname}/"
            fi
          done
        }
        
        # Deploy files individually to BunnyCDN
        echo "Deploying files to BunnyCDN..."
        
        # Create temporary directory for deployment
        mkdir -p deploy_temp
        
        # Copy all necessary files
        echo "Copying game files..."
        cp *.html deploy_temp/ 2>/dev/null || true
        cp *.css deploy_temp/ 2>/dev/null || true
        cp *.js deploy_temp/ 2>/dev/null || true
        cp *.json deploy_temp/ 2>/dev/null || true
        cp -r src deploy_temp/ 2>/dev/null || true
        cp -r assets deploy_temp/ 2>/dev/null || true
        
        # Upload files using the upload_directory function
        echo "Uploading files to BunnyCDN..."
        upload_directory "deploy_temp" "/"
        
        # Cleanup
        rm -rf deploy_temp
        
        echo "Upload completed!"

  purge-cache:
    runs-on: ubuntu-latest
    needs: deploy
    
    steps:
    - name: Purge BunnyCDN Cache
      env:
        BUNNY_API_KEY: ${{ secrets.BUNNY_API_KEY }}
        BUNNY_PULL_ZONE_ID: ${{ secrets.BUNNY_PULL_ZONE_ID }}
      run: |
        echo "Purging CDN cache..."
        curl -X POST \
          -H "AccessKey: $BUNNY_API_KEY" \
          --fail-with-body \
          "https://api.bunny.net/pullzone/${BUNNY_PULL_ZONE_ID}/purgeCache"
        echo "Cache purged successfully!"

  create-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Create Release
      if: success()
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        echo "üè∑Ô∏è Creating release..."
        
        # Configurer Git pour les actions automatiques
        git config --global user.email "action@github.com"
        git config --global user.name "GitHub Action"
        
        # Calculer la nouvelle version bas√©e sur les tags existants et les commits
        LATEST_TAG=$(git tag --sort=-version:refname | head -n1)
        
        if [ -z "$LATEST_TAG" ]; then
          # Aucun tag existant, cr√©er v1.0.0
          NEW_VERSION="v1.0.0"
          echo "üÜï Premier tag - Cr√©ation de la version initiale"
        else
          # Extraire les composants de version du dernier tag
          VERSION_NUMBER=$(echo $LATEST_TAG | sed 's/v//')
          MAJOR=$(echo $VERSION_NUMBER | cut -d. -f1)
          MINOR=$(echo $VERSION_NUMBER | cut -d. -f2)
          PATCH=$(echo $VERSION_NUMBER | cut -d. -f3)
          
          # Compter les commits depuis le dernier tag
          COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
          
          if [ "$COMMITS_SINCE_TAG" -eq 0 ]; then
            echo "‚ö†Ô∏è Aucun nouveau commit depuis le tag $LATEST_TAG - Pas de nouvelle release"
            exit 0
          fi
          
          echo "üìä $COMMITS_SINCE_TAG commit(s) depuis le tag $LATEST_TAG"
          
          # Analyser tous les commits depuis le dernier tag
          COMMITS_MESSAGES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s")
          
          # D√©terminer le type de version bas√© sur les commits
          HAS_BREAKING=false
          HAS_FEAT=false
          
          while IFS= read -r commit_msg; do
            if echo "$commit_msg" | grep -q "BREAKING CHANGE\|^feat!\|^fix!\|^docs!\|^style!\|^refactor!\|^perf!\|^test!\|^build!\|^ci!\|^chore!"; then
              HAS_BREAKING=true
              break
            elif echo "$commit_msg" | grep -q "^feat\|^feature"; then
              HAS_FEAT=true
            fi
          done <<< "$COMMITS_MESSAGES"
          
          # Calculer la nouvelle version
          if [ "$HAS_BREAKING" = true ]; then
            # Breaking change = version majeure
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            echo "üí• Breaking change d√©tect√© ‚Üí Version majeure"
          elif [ "$HAS_FEAT" = true ]; then
            # Nouvelle fonctionnalit√© = version mineure
            MINOR=$((MINOR + 1))
            PATCH=0
            echo "‚ú® Nouvelle fonctionnalit√© d√©tect√©e ‚Üí Version mineure"
          else
            # Fix, docs, style, etc. = version patch
            PATCH=$((PATCH + 1))
            echo "üîß Corrections/am√©liorations d√©tect√©es ‚Üí Version patch"
          fi
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        fi
        
        echo "üìã Latest tag: ${LATEST_TAG:-"none"}"
        echo "üî¢ New version: $NEW_VERSION"
        
        # Cr√©er le r√©pertoire de release
        mkdir -p release
        
        # Copier tous les fichiers du jeu
        cp *.html release/ 2>/dev/null || true
        cp *.css release/ 2>/dev/null || true
        cp *.js release/ 2>/dev/null || true
        cp *.json release/ 2>/dev/null || true
        cp -r src release/ 2>/dev/null || true
        cp -r assets release/ 2>/dev/null || true
        cp README.md release/ 2>/dev/null || true
        
        # Cr√©er un README pour la release
        cat > release/INSTALL.md << EOF
        # Tower Rush ${NEW_VERSION}
        
        ## Installation
        1. Extraire tous les fichiers
        2. Ouvrir \`index.html\` dans un navigateur moderne
        3. Ou servir via un serveur web local pour le multijoueur
        
        ## Serveur local (recommand√© pour multijoueur)
        \`\`\`bash
        # Python 3
        python3 -m http.server 8000
        
        # Node.js
        npx serve .
        
        # PHP
        php -S localhost:8000
        \`\`\`
        
        Puis aller sur http://localhost:8000
        
        ## Fonctionnalit√©s
        - Mode solo contre IA
        - Mode multijoueur jusqu'√† 4 joueurs (WebRTC)
        - Syst√®me de profils et avatars
        - Classement des scores
        - Interface responsive
        
        ## Support
        - Repository: https://github.com/gtko/towerRush
        - Issues: https://github.com/gtko/towerRush/issues
        EOF
        
        # Cr√©er les fichiers zip
        cd release
        zip -r "../tower-rush-${NEW_VERSION}.zip" . -x "*.DS_Store" "*.git*"
        zip -r "../tower-rush-game.zip" . -x "*.DS_Store" "*.git*"
        cd ..
        
        echo "üì¶ Created release files:"
        ls -la *.zip
        
        # G√©n√©rer les notes de release
        if [ -n "$LATEST_TAG" ]; then
          COMMIT_MESSAGES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s")
          COMMITS_COUNT=$(git rev-list ${LATEST_TAG}..HEAD --count)
        else
          COMMIT_MESSAGES=$(git log --pretty=format:"- %s")
          COMMITS_COUNT=$(git rev-list HEAD --count)
        fi
        
        cat > release_notes.md << EOF
        ## üéÆ Tower Rush ${NEW_VERSION}
        
        ### üìä Statistiques
        - **${COMMITS_COUNT} commits** depuis la derni√®re version
        - **Derni√®re version** : ${LATEST_TAG:-"Premi√®re release"}
        
        ### üìã Changements
        
        ${COMMIT_MESSAGES}
        
        ### üöÄ Installation
        
        1. T√©l√©chargez \`tower-rush-${NEW_VERSION}.zip\`
        2. Extrayez le fichier zip
        3. Ouvrez \`index.html\` dans votre navigateur
        
        ### üéØ Fonctionnalit√©s
        
        - ‚úÖ Mode solo contre IA intelligente
        - ‚úÖ Mode multijoueur jusqu'√† 4 joueurs (WebRTC P2P)
        - ‚úÖ Syst√®me de profils avec avatars personnalis√©s
        - ‚úÖ Classement global des scores
        - ‚úÖ Interface moderne et responsive
        - ‚úÖ Contr√¥les intuitifs (souris + clavier)
        
        ### üåê Jouer en ligne
        
        [**üéÆ Jouer maintenant**](https://gtko.github.io/towerRush/)
        
        ### üêõ Signaler un probl√®me
        
        [Cr√©er une issue](https://github.com/gtko/towerRush/issues/new)
        EOF
        
        echo "üìù Release notes created"
        
        # Cr√©er le tag git
        git tag "$NEW_VERSION" -m "Release ${NEW_VERSION}"
        git push origin "$NEW_VERSION"
        
        # Cr√©er la release via GitHub CLI
        gh release create "$NEW_VERSION" \
          "tower-rush-${NEW_VERSION}.zip#Jeu complet (${NEW_VERSION})" \
          "tower-rush-game.zip#Jeu complet (version g√©n√©rique)" \
          --title "üéÆ Tower Rush ${NEW_VERSION}" \
          --notes-file release_notes.md \
          --latest
        
        echo "‚úÖ Tag ${NEW_VERSION} cr√©√© et release publi√©e avec succ√®s!"
        
        # Nettoyage
        rm -rf release *.zip release_notes.md

  deploy-summary:
    runs-on: ubuntu-latest
    needs: [deploy, purge-cache, create-release]
    if: always()
    
    steps:
    - name: Deploy Summary
      run: |
        echo "üöÄ Deployment completed!"
        echo "üì¶ Files uploaded to BunnyCDN Storage Zone"
        echo "üåê Your site should be available at your configured BunnyCDN URL"
        echo "üè∑Ô∏è Release created automatically"
        echo "‚è∞ Deployed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"